#!/usr/bin/perl
#
# blog2mail
# Michael Shields <shields@msrl.com>
# $Id$
#
# This works with Blogger, Blosxom, Radio Userland, and many homespun tools.
#

use CGI qw(escapeHTML);
use DB_File;
use Fcntl;
use IO::File;
use LWP::UserAgent;
use HTML::Entities;
use HTTP::Headers;
use HTTP::Request;
use Mail::Internet;
use MIME::QuotedPrint;
use Sys::Hostname;
use URI;
use XML::RSS;
use strict;

$#ARGV == 2
    or die "usage: blog2mail URL FROM MAILDIR\n";
my $url = $ARGV[0];
my $from = $ARGV[1];
my $maildir = $ARGV[2];
$maildir =~ s,/$,,;
-d "$maildir/new" && -d "$maildir/tmp"
    or die "not a maildir: $maildir\n";
my $message = 0;

my $uri = new URI $url
    or die "couldn't parse URL: $url\n";
# FIXME Spurious "<b></b>" here works around a bug in w3m-el that causes
# all text to be bolded up to the first </b>.  --Shields 2003-03-30
my $html_header = "<html><head><base href=\"".$uri->scheme()."://"
                  .$uri->host."\"></head>\n"
		  ."<body><b>&nbsp;</b><em>&nbsp;</em><br>\n";
my $html_footer = "</body></html>\n";

tie my %cache, 'DB_File', "$ENV{HOME}/.blog2mail",
    O_CREAT|O_RDWR, 0600
    or die "couldn't tie: $!\n";

my $ua = new LWP::UserAgent;
my $headers = new HTTP::Headers;
# This is better than using the if_modified_since method, which uses
# native time_t arguments; see notes to RFC 2616 section 14.25.
$headers->header('If-Modified-Since' => $cache{$url}) if $cache{$url};
my $request = new HTTP::Request('GET' => $url, $headers);
my $response = $ua->request($request);
if ($response->code == 304) {	# not modified
    exit 0;
} elsif ($response->is_redirect) {
    die "redirection of $url not implemented\n";  # FIXME
} elsif ($response->is_error) {
    die "error getting $url: ", $response->status_line, "\n";
}
$cache{$url} = $response->header('Last-Modified')
    if $response->header('Last-Modified');

my $raw_rss = $response->content;

{
    # This shouldn't be necessary, and is not really correct.  However,
    # people do manage to put characters in their blogs that are not even
    # valid UTF-8, and that chokes the XML::RSS parser.
    use utf8;
    $raw_rss =~ s/([^\0-\176])/sprintf "&#x%x;", ord $1/eg;
    use bytes;
    $raw_rss =~ s/([^\0-\176])/sprintf "\\%03o", ord $1/eg;
}

# more hackaround:
$raw_rss =~ s/&(?=\s)/&amp;/g;

my $rss = new XML::RSS;
$rss->parse($raw_rss)
    or die "couldn't parse RSS for $url\n";

foreach my $item (reverse @{$rss->{items}}) {

    my $item_url = $item->{link} || $item->{guid}
	or die "couldn't find link for item $item->{title}\n";

    next if $cache{$item_url};

    my $mail = new Mail::Internet;
    $mail->head->add('X-URL', $item_url);
    $mail->head->add('From', $from);
    $mail->head->add('User-Agent', 'blog2mail/0.0');
    $mail->head->add('MIME-Version', '1.0');
    $mail->head->add('Content-Type', 'text/html');
    if (defined $item->{dc} && defined $item->{dc}{date}) {
	$mail->head->add('Date', iso8601_to_rfc2822($item->{dc}{date}));
    } elsif (defined $item->{pubDate}) {
	$mail->head->add('Date', $item->{pubDate});
    }

    # RFC 2047 encoding of UTF-8 headers.
    # FIXME Mail::Header should really handle this internally...
    my $subject = decode_entities($item->{title});
    if ($subject =~ /[^\040-\176]/) {
        $subject = encode_qp($subject);
	$subject = "=?utf-8?q?$subject?=";
    }
    $mail->head->add('Subject', $subject);

    my $body;
    if (defined $item->{'http://purl.org/rss/1.0/modules/content/'}) {
	$body = $item->{'http://purl.org/rss/1.0/modules/content/'}{encoded};
    } elsif (defined $item->{content}) {
	$body = $item->{content}{encoded};
    } elsif (defined $item->{description}) {
	$body = $item->{description};
	# Bad hack for Radio Userland:
	$body =~ s,\n\n,<br />\n<br />\n,g;
    } else {
	$body = "<a href=\"$item->{link}\">"
		. escapeHTML($item->{link}) . "</a>\n";
    }

    $mail->body($html_header . $body . $html_footer);

    my $filename = time . ".${$}_$message." . hostname;
    $message++;
    my $fh = new IO::File;
    open($fh, '>', "$maildir/tmp/$filename")
	or die "couldn't open $maildir/tmp/$filename: $!\n";
    $mail->print($fh)
	or die "couldn't write to $maildir/tmp/$filename: $!\n";
    close $fh;
    rename "$maildir/tmp/$filename", "$maildir/new/$filename"
	or die "couldn't rename $maildir/tmp/$filename: $!\n";

    $cache{$item_url} = time;
}

untie %cache;

exit 0;



sub iso8601_to_rfc2822 {
    $_[0] =~ /^(\d\d\d\d)-(\d\d)-(\d\d)T(\d\d:\d\d:\d\d)(\.\d+)?([-+]\d\d):?(\d\d)$/
	or die "couldn't parse date: $_[0]\n";
    sprintf '%d %s %d %s %s:%s', $3,
	    (qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec))[$2-1],
	    $1, $4, $6, $7;
}
